#!/usr/bin/python
# -*- coding: UTF-8 -*-

"""
class of Heatmap
"""

import numpy as np
import scipy.stats as st
import cv2

class Heatmap:
    """
    class of Heatmap
    """
    def __init__(self, original_data):
        self.original_data = original_data
        self.height = 0
        self.width = 0
        self.columns = 0
        self.rows = 0
        self.row_height = 0
        self.column_width = 0
        self.heatmap = None

    def __get_width_and_height(self):
        """
        get width and height from json file
        :return: width and height
        """
        self.width = int(self.original_data['width'])
        self.height = int(self.original_data['height'])

    def __get_number_of_rows_and_columns(self):
        """
        get number of columns and rows of shelf from json file
        :return: number of columns and rows
        """
        self.rows = int(self.original_data['row'])
        self.columns = int(self.original_data['col'])

    def __get_rowHeight_and_columnWidth(self):
        """
        get row height and columns width
        :return: row height and columns width
        """
        self.__get_width_and_height()
        self.__get_number_of_rows_and_columns()
        self.column_width, self.row_height = self.width / self.columns, self.height / self.rows

    def __generate_original_heatmap(self):
        """
        generate a 2D matrix whose (x,y) is where eye followed
        and whose value is the duration
        :return: a 2D matrix
        """
        self.__get_rowHeight_and_columnWidth()
        original_heatmap = np.zeros((self.height, self.width))
        for d in self.original_data['data']:
            x = int((d['x'] + 0.5) * self.column_width)
            y = int((4 - (d['y']) + 0.5) * self.row_height)
            value = d['value']
            original_heatmap[y][x] += value

        return original_heatmap

    def __generate_original_heatmap_with_exact_coordinates(self):
        """
        adjust the 2D matrix into a new coordinate system
        :return:
        """
        self.__get_rowHeight_and_columnWidth()
        original_heatmap = np.zeros((self.height, self.width))
        for d in self.original_data['data']:
            x = int(d['x'] + 0.5 * self.width)
            y = int(0.5 * self.height - d['y'])
            value = d['value']
            if (x > self.width or y > self.height):
                continue
            original_heatmap[y][x] += value

        return original_heatmap

    def __generate_gaussian_kernel(self, kernlen, nsig=3):
        """Returns a 2D Gaussian kernel."""

        x = np.linspace(-nsig, nsig, kernlen + 1)
        kern1d = np.diff(st.norm.cdf(x))
        kern2d = np.outer(kern1d, kern1d)
        return kern2d / kern2d.sum()

    def __blur_original_heatmap_with_gaussian_kernel(self, original_heatmap, gaussian_kernel):
        """
        blur the 2D matrix with generated gaussian kernel
        :param original_heatmap: the 2D matrix
        :param gaussian_kernel:
        :return: real heatmap foreground
        """
        self.heatmap = cv2.filter2D(original_heatmap, -1, gaussian_kernel)

    def generate_heatmap(self):
        """
        main function to generate heatmap
        :return:
        """
        # originalHeatmap = self.__generate_original_heatmap() # removed cause we don't have to adjust coordinate any more
        originalHeatmap = self.__generate_original_heatmap_with_exact_coordinates()
        gaussianKernel = self.__generate_gaussian_kernel(kernlen=int(0.09 * np.sqrt(self.width * self.height)))
        self.__blur_original_heatmap_with_gaussian_kernel(originalHeatmap, gaussianKernel)
        return self.heatmap

